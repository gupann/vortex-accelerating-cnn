diff --git a/hw/rtl/tcu/VX_tcu_fedp_bhf.sv b/hw/rtl/tcu/VX_tcu_fedp_bhf.sv
index d11cfc0f..77352e38 100644
--- a/hw/rtl/tcu/VX_tcu_fedp_bhf.sv
+++ b/hw/rtl/tcu/VX_tcu_fedp_bhf.sv
@@ -75,6 +75,7 @@ module VX_tcu_fedp_bhf #(
     for (genvar i = 0; i < TCK; i++) begin : g_prod
         wire [32:0] mult_result_fp16;
         wire [32:0] mult_result_bf16;
+        wire [32:0] mult_result_tf32; // shilpa changed
 
         // FP16 multiplication
         VX_tcu_bhf_fmul #(
@@ -118,11 +119,42 @@ module VX_tcu_fedp_bhf #(
             `UNUSED_PIN(fflags)
         );
 
+        // TF32 multiplication - shilpa changed
+        logic [32:0] mult_result_tf32_int;
+        if ((i % 2) == 0) begin : g_tf32_mul
+        // use lower 19 bits (1+8+10) from each 32-bit TF32 element
+            VX_tcu_bhf_fmul #(
+                    .IN_EXPW (8),
+                    .IN_SIGW (10+1),
+                    .OUT_EXPW(8),
+                    .OUT_SIGW(24),
+                    .IN_REC (0), // input in IEEE format
+                    .OUT_REC (1), // output in recoded format
+                    .MUL_LATENCY (FMUL_LATENCY),
+                    .RND_LATENCY (FRND_LATENCY)
+            ) tf32_mul (
+                .clk    (clk),
+                .reset  (reset),
+                .enable (enable),
+                .frm    (frm),
+                .a      (a_row[i/2][18:0]),
+                .b      (b_col[i/2][18:0]),
+                .y      (mult_result_tf32_int),
+                `UNUSED_PIN(fflags)
+            );
+        end else begin : g_tf32_zero
+            assign mult_result_tf32_int = '0; // interleave with zeroes 
+        end
+
+        assign mult_result_tf32 = mult_result_tf32_int; // both zeroes and multiplication for the next stage
+        // end shilpa changed
+
         logic [32:0] mult_result_mux;
         always_comb begin
             case(fmt_s_delayed)
                 3'd1: mult_result_mux = mult_result_fp16;
                 3'd2: mult_result_mux = mult_result_bf16;
+                3'd3: mult_result_mux = mult_result_tf32; // shilpa changed
                 default: mult_result_mux = 'x;
             endcase
         end
diff --git a/hw/rtl/tcu/VX_tcu_pkg.sv b/hw/rtl/tcu/VX_tcu_pkg.sv
index bd82aaa3..73cde0c3 100644
--- a/hw/rtl/tcu/VX_tcu_pkg.sv
+++ b/hw/rtl/tcu/VX_tcu_pkg.sv
@@ -29,6 +29,7 @@ package VX_tcu_pkg;
     localparam TCU_FP32_ID = 0;
     localparam TCU_FP16_ID = 1;
     localparam TCU_BF16_ID = 2;
+    localparam TCU_TF32_ID = 3; // shilpa changed
     localparam TCU_I32_ID  = 8;
     localparam TCU_I8_ID   = 9;
     localparam TCU_U8_ID   = 10;
@@ -86,6 +87,7 @@ package VX_tcu_pkg;
         case (fmt)
             TCU_FP32_ID: `TRACE(level, ("fp32"))
             TCU_FP16_ID: `TRACE(level, ("fp16"))
+            TCU_TF32_ID: `TRACE(level, ("tf32")) // shilpa changed
             TCU_BF16_ID: `TRACE(level, ("bf16"))
             TCU_I32_ID:  `TRACE(level, ("i32"))
             TCU_I8_ID:   `TRACE(level, ("i8"))
diff --git a/sim/common/tensor_cfg.h b/sim/common/tensor_cfg.h
index 9622ba92..99136ae2 100644
--- a/sim/common/tensor_cfg.h
+++ b/sim/common/tensor_cfg.h
@@ -43,6 +43,13 @@ struct bf16 {
   static constexpr const char* name = "bf16";
 };
 
+struct tf32 {
+  using dtype = uint32_t;
+  static constexpr uint32_t id = 3;
+  static constexpr uint32_t bits = 32;
+  static constexpr const char* name = "tf32";
+};
+
 struct int32 {
   using dtype = int32_t;
   static constexpr uint32_t id = 8;
@@ -83,6 +90,7 @@ inline const char* fmt_string(uint32_t fmt) {
   case fp32::id:  return fp32::name;
   case fp16::id:  return fp16::name;
   case bf16::id:  return bf16::name;
+  case tf32::id:  return tf32::name;
   case int32::id: return int32::name;
   case int8::id:  return int8::name;
   case uint8::id: return uint8::name;
diff --git a/sim/simx/tensor_unit.cpp b/sim/simx/tensor_unit.cpp
index 1bb6da3a..741ed798 100644
--- a/sim/simx/tensor_unit.cpp
+++ b/sim/simx/tensor_unit.cpp
@@ -71,6 +71,18 @@ struct FMA<vt::bf16, vt::fp32> {
   }
 };
 
+template <>
+struct FMA<vt::tf32, vt::fp32> {
+  static float eval(uint32_t a, uint32_t b, float c) {
+    auto xa  = rv_xtof_s(a, 8, 10, 0, nullptr);
+    auto xb  = rv_xtof_s(b, 8, 10, 0, nullptr);
+    auto xab = rv_fmul_s(xa, xb, 0, nullptr);
+    auto xc  = bit_cast<uint32_t>(c);
+    auto xd  = rv_fadd_s(xab, xc, 0, nullptr);
+    return bit_cast<float>(xd);
+  }
+};
+
 template <>
 struct FMA<vt::bf16, vt::bf16> {
   static uint16_t eval(uint16_t a, uint16_t b, uint16_t c) {
@@ -152,6 +164,8 @@ static PFN_FEDP select_FEDP(uint32_t IT, uint32_t OT) {
       return FEDP<vt::fp16, vt::fp32>::eval;
     case vt::bf16::id:
       return FEDP<vt::bf16, vt::fp32>::eval;
+    case vt::tf32::id:
+      return FEDP<vt::tf32, vt::fp32>::eval;
     default:
       std::cout << "Error: unsupported mma format: " << IT << " -> " << OT << "!" << std::endl;
       std::abort();
